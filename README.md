# RDLC_Serial_Protocol
在嵌入式开发中，总是要碰上两台设备相互通信的场景，一般做法是加一个包头包尾，然后由通信双方自行负责解析。<br>
写那么一次两次还好，反复地写不免让人有些烦躁。<br>
正因如此，不妨把分包和校验的流程打包成硬件无关的通用字节流协议，随时随地想在哪用就在哪用。<br>

## 简介
RDLC协议由帧头0xC0、端口号、载荷长度、CRC16校验码和帧尾0x0C构成。端口号、载荷长度和CRC16均以uint16_t小端发送，载荷内容的大小端由用户决定。<br>
一般而言，串口通信双方不是同步的，因此数据包通常会被接收方截断。为了避免接收方误将截断数据中的载荷识别为帧头帧尾，RDLC协议引入了转义机制。<br>
即帧头转义为0xFF 0xC0，帧尾转义为0xFF 0x0C，帧中的0xFF转义为两个连续的0xFF。除此之外，其他字节不进行转义，例如帧中的0xC0、0x0C。<br>
RDLC协议的"端口"借鉴自TCP/IP网络，即多个实体可以利用同一个信道传递各自的信息，并利用端口号区分彼此。<br>
RDLC协议使用C语言面向对象的方式实现。对象类型为Rdlc_t，构造函数为xRdlcCreate/xRdlcCreateStatic，析构函数为vRdlcDestroy。<br>
考虑到需要跨平台，本协议要求使用者手动传入RDLC工作所需的系统调用函数，即RdlcPort_t中定义的函数指针。<br>
系统调用函数可以全部取nullptr，此时RDLC协议将不会输出任何日志，以及不会动态申请空间。当然--在这种情况下，所有的空间都要在一开始以静态的方式预留。<br>

## 使用方式
- 将rdlc.c和rdlc.h拷贝到您的项目中。
- 根据需求修改rdlc.h中的配置宏。
- 根据你的平台，编写对应的系统调用函数。例如FreeRTOS下使用pvPortMalloc/vPortFree。
- 根据需求，编写协议回调函数，然后通过调用构造函数的方式，完成协议的初始化。
- 在需要发送数据时，调用xRdlcWriteBytes把原始数据打包成帧，然后调用您的发送函数（例如HAL_UART_Transmit_IT）将帧发送出去。
- 在合适的位置（例如HAL_UART_RxCpltCallback）调用xRdlcReadByte/xRdlcReadBytes，让协议接收字节。
- 当协议内的状态机完成字节接收后，会自动调用此前你注册的回调函数。

## 参考代码
- 提供ESP32在IDFv5.4下使用RDLC的例程。
- 提供STM32在HAL库+CubeMX下的例程。
- 提供STM32F103在标准库下的例程。由于CH32X035G8的BSP库和ST标准库相似，代码可以兼容。
